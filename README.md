I implemented TypeScript features throughout the project by explicitly asserting return types for functions, variables, and parameters to ensure strong type safety. This helped me catch errors early and understand the flow of data more clearly. I also applied core object oriented programming principles such as inheritance, encapsulation, and abstraction. Inheritance was demonstrated through the custom HandlerError class, which extends the built-in Error class to create a more descriptive and specialized error-handling system. Encapsulation was shown by grouping related logic within classes and utility modules, keeping responsibilities clean and organized. Abstraction came into play by hiding internal implementation details, such as discount logic, tax calculations, and fetch requests; behind well-defined functions and class methods.
The main challenges I encountered involved structuring the fetch logic for the two different API endpoints and understanding how to properly extract and map the returned JSON data into my Product class. I also had to think carefully about where to implement try/catch blocks and how to throw custom errors so that failures were handled gracefully. Another challenge was properly chaining promises using both traditional .then() syntax versus the more modern async/await syntax. At first, keeping track of asynchronous data flow felt confusing, especially when deciding where to return values or how to shape the resolved data for later use.
I overcame these challenges by reviewing documentation, experimenting with small test functions, and gradually refactoring my code to make each piece simpler and more predictable. Breaking the problem down into smaller steps, fetching data, converting it into a class instance, applying discounts or taxes, and finally displaying resultsâ€”\ made the entire workflow easier to understand. Overall, this project strengthened my confidence with TypeScript, asynchronous programming, and building clean, modular application logic.

https://github.com/unw10181/sba6
